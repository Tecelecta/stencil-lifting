#include "SDSL/ErrorHandlerStream.h"
#include "SDSL/Lexer.h"
#include "SDSL/Parser.h"
#include "SDSL/SectionConstructor.h"

#include "VCG/Optimize.h"

#include "Backend/PrintSdslCodePass.h"
#include "Backend/PrintCudaCodePass.h"
#include "Backend/PrintHalideCodePass.h"

#include <sstream>
#include <fstream>

#include "cmdline.h"

std::vector<Value*> getReturnArrays(GraphValueProjection& graph)
{
	std::vector<Value*> returnValues;
	for (auto section : graph.getRootSections())
	{
		auto vars = section->getVariableVector();
		for (auto value : vars)
		{
			if (value->getType().cast<ArrayType>() != nullptr)
			{
				if (graph.getDataflowByVertex(graph.vertexId(value)).empty())
				{
					returnValues.push_back(value);
				}
			}
		}
	}
	return returnValues;
}

int main(int argc, char* argv[])
{
	// 
	cmdline::parser cmd;

	cmd.add<std::string>("output", 'o', "Output file path", false);
	cmd.add<std::string>("target", '\0', "types of output code", false);
	cmd.add("syntax-only", '\0', "syntax check only");
	cmd.add("print-ast", '\0', "Dump the AST generated by syntax analyzer");

	cmd.parse_check(argc, argv);
	auto output(cmd.get<std::string>("output"));
	auto target(cmd.get<std::string>("target"));

	bool syntax_only = cmd.exist("syntax-only");
	bool print_ast = cmd.exist("print-ast");

	ErrorHandlerStream errorHandler;
	auto inputs(cmd.rest());
	if (inputs.empty())
	{
		errorHandler.error("No input file");
		return 1;
	}

	auto t_start = clock();
	// IR
	auto context = std::make_unique<Context>();
	SectionConstructor sectionConstructor(errorHandler, context.get());
	std::vector<FunctionDefinition> allFunctions;
	for (const auto& input : inputs)
	{
		std::cout << input << std::endl;

		std::ifstream input_file(input);
		if (!input_file.is_open())
		{
			errorHandler.error("Cannot open file '" + input + "'");
			continue;
		}
		std::string file_contents((std::istreambuf_iterator<char>(input_file)), std::istreambuf_iterator<char>());

		Lexer lexer(errorHandler);
		auto tokenStream = lexer.run(file_contents);
		if (errorHandler.errorCount > 0)
		{
			continue;
		}
		if (print_ast)
		{
			std::cout << "\n ---------- Parsing ---------- \n";
		}
		auto ast = CompileUnitParser(errorHandler).run(tokenStream);
		if (errorHandler.errorCount > 0)
		{
			continue;
		}
		if (print_ast)
		{
			std::cout << "\nAST:\n";
			printASTNode(ast.get());
		}
		if (syntax_only)
		{
			continue;
		}
		std::cout << "\n ---------- Generating IR ---------- \n";
		sectionConstructor.runOnCompileUnit(ast.get(), allFunctions);
	}

	if (errorHandler.errorCount > 0)
	{
		return 1;
	}
	if (syntax_only)
	{
		return 0;
	}
	if (allFunctions.empty())
	{
		errorHandler.warning("Valid function defination not found");
		return 0;
	}
	std::unordered_set<String> initUsefulSymbols;
	std::vector<Section*> allSections;
	allSections.reserve(allFunctions.size());
	for (const auto& fn : allFunctions)
	{
		initUsefulSymbols.insert(fn.section->getName());
		for (auto ret : fn.returnValues)
		{
			if (ret->getType().cast<ArrayType>() != nullptr)
			{
				initUsefulSymbols.insert(ret->getName());
			}
		}
		allSections.push_back(fn.section);
	}
	GraphValueProjection graph(allSections);
	graph.validate();
	printf("SubgraphNum = %u, VertexNum = %u\n", graph.getSubgraphNum(), graph.getVertexNum());
	context->deleteUseless();

	// 
	graph = runOptimizeLevel3(graph, initUsefulSymbols);
	context->deleteUseless();

	// IR
	std::ofstream out_file;
	if (!output.empty())
	{
		out_file.open(output);
		if (!out_file.is_open())
		{
			errorHandler.warning("Cannot open file '" + output + "', output is directed to console");
		}
	}

	auto returnValues = getReturnArrays(graph);
	auto& out = out_file.is_open() ? out_file : std::cout;
	if (target == "cpu")
	{
		PrintFortranModulePass(out).run(graph, returnValues, "test");
	}
	else if (target == "cuda")
	{
		PrintFortranCudaModulePass(out).run(graph, returnValues, "test");
	}
	else if (target == "halide")
	{
		out << "#include \"Halide.h\"\n\n";
		PrintHalideModulePass(out).run(graph, returnValues);
	}
	else
	{
		PrintSdslModulePass(out).run(graph, returnValues);
	}

	std::cout << "Total-time: " << double(clock() - t_start) / CLOCKS_PER_SEC << " sec" << std::endl;
	std::cout << "\n ---------- END ---------- \n\n";
	return 0;
}
